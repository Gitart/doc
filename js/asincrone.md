# События и асинхронность

В первом примере в этой главе мы научились обрабатывать как щелчки кнопкой
мыши, так и нажатие клавиши на клавиатуре. В общем, мы можем обработать лю-
бое событие с помощью шаблона on . Например, можем реагировать на событие
dbclick , которое происходит, когда пользователь делает двойной щелчок кнопкой
мыши:

```js
$(".button").on("dblclick", function () {
alert("Эй! Ты дважды щелкнул кнопкой мыши!");
});Общие сведения о jQuery
```


В общем случае такой стиль программирования называется событийно-ориен-
тированным (event-driven) или асинхронным (asynchronous) программированием.
В чем его отличие от традиционного программирования? Наш код, вероятно, ра-
ботал бы примерно так:

```js
console.log("это выводится первым");
console.log("это выводится вторым");
console.log("это выводится третьим");
```

При асинхронном программировании функции, связанные с событиями, при-
нимают обратные вызовы или функции, которые должны исполняться позднее,
в качестве аргументов. Из-за этого понять порядок исполнения не всегда легко:

```js
console.log("это выводится первым");
$("button").on("click", function () {
console.log("это выводится, когда кто-то щелкает кнопкой мыши");
});
console.log("это выводится вторым");
```

Вот еще один пример, где для выполнения обратного вызова пользовательский
ввод не требуется. Мы уже видели функцию ready , которая ожидает, пока DOM не
будет готова выполнить обратный вызов. Функция setTimeout ведет себя аналогич-
но, но выполняет обратный вызов по прошествии определенного количества мил-
лисекунд:

```
// Это событие jQuery, выполняющее обратный вызов,
// как только DOM готова. В этом примере мы используем
// анонимную функцию вместо отправки функции main аргумента
$(document).ready(function () {
console.log("Это будет выведено, как только документ будет готов");
});
// А это функция, встроенная в JavaScript, которая
// выполняется по прошествии определенного количества миллисекунд
setTimeout(function () {
console.log("Это будет выведено через 3 секунды");
}, 3000);
// это будет выведено перед чем-либо еще, даже если
// появится последним
console.log("Это будет выведено первым");
```

На данный момент событийно-управляемое программирование, базирующееся
на пользовательском взаимодействии, вполне может иметь место, а в примерах,
включающих функции setTimeout и ready , разобраться несложно. Проблемы начи-
наются, когда мы хотим расположить события последовательно. Например, пред-
ставьте ситуацию, в которой мы используем функцию jQuery slideDown для того,
чтобы отобразить скользящее раскрытие какого-то текста:

```js
var main = function () {
"use strict";
// создаем и скрываем содержимое в div
var $content = $("<div>Hello, World!</div>").hide();128
Глава 4. Интерактивность
// делаем его потомком элемента body
$("body").append($content);
// добавляем скользящее отображение за 2 секунды
$content.slideDown(2000);
};
$(document).ready(main);
```

А теперь допустим, что мы хотим добавить постепенное отображение второго
сообщения после того, как все содержимое появится. Скорее всего, мы испробуем
что-то вроде следующего:

```js
var main = function () {
"use strict";
// создаем и скрываем содержимое в div
var $content = $("<div>Hello, World!</div>").hide();
var $moreContent = $("<div>Goodbye World!</div>").hide();
// делаем его потомком элемента body
$("body").append($content);
// добавляем скользящее отображение за 2 секунды
$content.slideDown(2000);
// добавляем еще один элемент в body
$("body").append($moreContent);
// и плавно отображаем его
$moreContent.fadeIn();
}
$(document).ready(main);
```

Попробуйте набрать этот код и запустить его. Вы увидите, что текст «Goodbye,
World!» постепенно отображается одновременно с тем, как раскрывается текст
«Hello, World!». Это определенно не то, что нам нужно. Остановитесь на секунду
и подумайте, почему так произошло.
Вы, наверное, догадались, что функция slideDown работает асинхронно. Это
значит, что код, который за ней следует, выполняется одновременно с раскрытием
текста! К счастью, jQuery предлагает обходной путь — большинство асинхронных
функций принимают обратный вызов в качестве опционального параметра как свой
последний аргумент, который позволяет располагать асинхронные события одно
за другим. Таким образом, мы можем добиться нужного эффекта, изменив код вот
так:

```js
var main = function () {
"use strict";
// создаем и тут же скрываем комментарий в элементе div
var $content = $("<div>Hello, World!</div>").hide();
var $moreContent = $("<div>Goodbye, World!</div>").hide();
// отправляем содержимое в элемент body
$("body").append($content);
// заставляем содержимое постепенно раскрываться вниз за 2 секунды,
// а затем выполняем обратный вызов, в котором
// находится другое содержимое
$content.slideDown(2000, function () {Общие характеристики JavaScript
// отправляем новое содержимое в body
$("body").append($moreContent);
// заставляем новое содержимое постепенно отобразиться
$moreContent.fadeIn();
});
};
$(document).ready(main);
```

Чтобы закончить пример из предыдущей секции, нужен тот же подход. Для уда-
ления элемента р из подвала после того, как он постепенно исчез, нужно проделать
следующее:

```js
$("footer p").fadeOut(1000, function () {
// это происходит, когда элемент p
// постепенно исчезает
$("footer p").remove();
});
```

Позднее в этой книге мы познакомимся с другими примерами асинхронного
программирования с помощью Node.js, но сейчас нужно хорошенько разобраться
с этими функциями и изучить шаблоны.

